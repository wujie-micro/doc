import{_ as e,o,c as a,Q as s}from"./chunks/framework.fe3fd81d.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{"sidebarDepth":2,"collapsable":false},"headers":[],"relativePath":"question/index.md","lastUpdated":1661653654000}'),t={name:"question/index.md"},n=s(`<h2 id="_1、请求资源报错" tabindex="-1">1、请求资源报错 <a class="header-anchor" href="#_1、请求资源报错" aria-label="Permalink to &quot;1、请求资源报错&quot;">​</a></h2><p>请求报错为：<code>Access to fetch at *** from origin *** has been blocked by CORS policy: No &#39;Access-Control-Allow-Origin&#39;</code></p><p><strong>原因：</strong> 子应用跨域或者请求子应用资源没有携带 cookie</p><p><strong>解决方案：</strong></p><ol><li><p>如果是跨域导致的错误，参考 <a href="/doc/guide/start.html#前提">前提</a></p></li><li><p>如果是求资源没有携带 cookie（一般请求返回码是 302 跳转到登录页），需要通过自定义 <a href="/doc/api/startApp.html#fetch">fetch</a> 将<code>fetch</code>的<code>credentials</code>设置为<code>include</code>，这样<code>cookie</code>才会携带上去</p></li></ol><div class="warning custom-block"><p class="custom-block-title">警告</p><p>当<code>credentials</code>设置为<code>include</code>时，服务端的<code>Access-Control-Allow-Origin</code>不能设置为<code>*</code>，原因<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#credentialed_requests_and_wildcards" target="_blank" rel="noreferrer">详见</a>，服务端可以这样设置：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">ctx</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">set</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Access-Control-Allow-Origin</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> ctx</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">headers</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">origin)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span></code></pre></div></div><h2 id="_2、第三方包已经引入-使用时报错" tabindex="-1">2、第三方包已经引入，使用时报错 <a class="header-anchor" href="#_2、第三方包已经引入-使用时报错" aria-label="Permalink to &quot;2、第三方包已经引入，使用时报错&quot;">​</a></h2><p><strong>原因：</strong> 脚本本来在全局执行，此时第三方包定义的全局变量（比如<code>var xxx</code>）会直接挂载到<code>window</code>上。但是<code>wujie</code>将所有的脚本都包裹在一个闭包内运行方便劫持修改<code>location</code>，所以这些全局变量会留在闭包内，无法挂载到<code>window</code>上，子应用的异步脚本会在另一个闭包内运行，所以拿不到这些全局变量。</p><p><strong>解决方案：</strong></p><p>1、方式一：需要将第三方包定义的全局变量显式的挂载到<code>window</code>上（比如<code>window.xxx</code>），或者修改第三方包<code>webpack</code>的<a href="https://webpack.docschina.org/configuration/output/#outputlibrarytarget" target="_blank" rel="noreferrer"><code>output.libraryTarget</code></a></p><p>2、方式二：如果用户不想修改代码可以通过<a href="/doc/guide/plugin.html#js-loader">插件</a>的形式在运行时将全局定义的代码 <code>xxx=</code>替换成<code>window.xxx=</code></p><h2 id="_3、子应用的字体没有生效" tabindex="-1">3、子应用的字体没有生效 <a class="header-anchor" href="#_3、子应用的字体没有生效" aria-label="Permalink to &quot;3、子应用的字体没有生效&quot;">​</a></h2><p><strong>原因：</strong> <code>@font-face</code>不会在<code>shadow</code>内部加载，<a href="https://github.com/mdn/interactive-examples/issues/887" target="_blank" rel="noreferrer">详见</a></p><p><strong>已解决：</strong> 框架会将子应用的<code>@font-face</code>放到<code>shadow</code>外部执行，注意子应用的自定义字体名和主应用的自定义字体名不能重复，否则可能存在覆盖问题</p><h2 id="_4、冒泡系列组件-比如下拉框-弹出位置不正确" tabindex="-1">4、冒泡系列组件（比如下拉框）弹出位置不正确 <a class="header-anchor" href="#_4、冒泡系列组件-比如下拉框-弹出位置不正确" aria-label="Permalink to &quot;4、冒泡系列组件（比如下拉框）弹出位置不正确&quot;">​</a></h2><p><strong>原因：</strong> 比如<code>element-plus</code>采用了<code>popper.js</code>2.0 版本，这个版本计算位置会递归元素一直计算到<code>window.visualViewport</code>，但是子应用的<code>dom</code>挂载在<code>shadowRoot</code>上，并没有<code>window.visualViewport</code>这部分滚动量，导致偏移计算失败</p><p><strong>解决方案：</strong> 将子应用将<code>body</code>设置为<code>position: relative</code>即可</p><h2 id="_5、子应用处理异步处理事件时-e-target-变成了-wujie-app" tabindex="-1">5、子应用处理异步处理事件时，e.target 变成了 wujie-app <a class="header-anchor" href="#_5、子应用处理异步处理事件时-e-target-变成了-wujie-app" aria-label="Permalink to &quot;5、子应用处理异步处理事件时，e.target 变成了 wujie-app&quot;">​</a></h2><p><strong>原因：</strong> 这个问题是浏览器原生的处理，<a href="https://stackoverflow.com/questions/63607966/event-target-changed-in-settimeout-in-shadow-dom" target="_blank" rel="noreferrer">详见</a></p><p><strong>解决方案：</strong> 在异步处理时，获取 e.target 的方式需要修改成： <code>(e.target.shadowRoot &amp;&amp; e.composed) ? (e.composedPath()[0] || e.target) : e.target</code></p><h2 id="_6、css-样式内部的相对地址相对的是主应用的域名" tabindex="-1">6、css 样式内部的相对地址相对的是主应用的域名 <a class="header-anchor" href="#_6、css-样式内部的相对地址相对的是主应用的域名" aria-label="Permalink to &quot;6、css 样式内部的相对地址相对的是主应用的域名&quot;">​</a></h2><p><strong>已解决：</strong> 框架已处理，默认将相对地址转换成绝对地址</p><h2 id="_7、子应用使用-module-federation-引用远程模块报错" tabindex="-1">7、子应用使用 module federation 引用远程模块报错 <a class="header-anchor" href="#_7、子应用使用-module-federation-引用远程模块报错" aria-label="Permalink to &quot;7、子应用使用 module federation 引用远程模块报错&quot;">​</a></h2><p><strong>原因：</strong> 原因<a href="#_2、第三方包已经引入-使用时报错">同 2</a>，都是由于闭包执行脚本导致脚本内的全局变量在其他脚本中无法读取</p><p><strong>解决方案：</strong> 在<code>ModuleFederationPlugin</code>插件中设置<code>library</code>的<code>type</code>为<code>window</code></p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">library</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">type</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">window</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#FFCB6B;">name</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">保持和name一致</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><h2 id="_8、子应用-iframe-初始化时加载、执行了主应用的资源" tabindex="-1">8、子应用 iframe 初始化时加载、执行了主应用的资源 <a class="header-anchor" href="#_8、子应用-iframe-初始化时加载、执行了主应用的资源" aria-label="Permalink to &quot;8、子应用 iframe 初始化时加载、执行了主应用的资源&quot;">​</a></h2><p><strong>原因：</strong> 原因详见<a href="https://github.com/Tencent/wujie/issues/54" target="_blank" rel="noreferrer">issue</a></p><p><strong>解决方案：</strong></p><ul><li>主应用提供一个路径比如说 <code>https://host/empty</code> ，这个路径返回不包含任何内容，子应用设置 <a href="/doc/api/startApp.html#attrs">attr</a> 为 <code>{src:&#39;https://host/empty&#39;}</code>，这样 iframe 的 src 就是 <code>https://host/empty</code></li><li>在主应用 template 的 head 第一个元素插入一个<code>&lt;script&gt;if(window.parent !== window) {window.stop()}&lt;/script&gt;</code>这样的标签应该可以避免主应用代码污染</li></ul><h2 id="_9、子应用-window-是一个代理对象-如何获取子应用的真实对象" tabindex="-1">9、子应用 window 是一个代理对象，如何获取子应用的真实对象 <a class="header-anchor" href="#_9、子应用-window-是一个代理对象-如何获取子应用的真实对象" aria-label="Permalink to &quot;9、子应用 window 是一个代理对象，如何获取子应用的真实对象&quot;">​</a></h2><p><strong>原因：</strong> 为何采用代理，原因详见<a href="https://github.com/Tencent/wujie/issues/63" target="_blank" rel="noreferrer">issue</a></p><p><strong>解决方案：</strong></p><ul><li>采用 <code>window.__WUJIE_RAW_WINDOW__</code> 获取真实的 window 对象，<a href="/doc/guide/variable.html#wujie-raw-window">详见</a></li></ul><h2 id="_10、domexception-blocked-a-frame-with-origin-from-accessing-a-cross-origin-frame-报错" tabindex="-1">10、DOMException: Blocked a frame with origin from accessing a cross-origin frame 报错 <a class="header-anchor" href="#_10、domexception-blocked-a-frame-with-origin-from-accessing-a-cross-origin-frame-报错" aria-label="Permalink to &quot;10、DOMException: Blocked a frame with origin from accessing a cross-origin frame 报错&quot;">​</a></h2><p><strong>可能原因：</strong> 子应用的沙箱被替换掉了，有三个原因：</p><ol><li>子应用运行在一个空白的、<code>src</code> 为主应用 <code>host</code> 的 <code>iframe</code> 中，这个 <code>host</code> 地址会发生 302 之类的跳转导致沙箱被弄掉了</li><li>子应用为 <code>vite</code> 应用，修改了 <code>window.location.href</code> 导致沙箱被替换掉了</li><li>子应用添加了 <a href="/doc/guide/plugin.html#js-ignores">jsIgnores</a> 的 <code>plugin</code>，对应的 <code>js</code> 文件修改了 <code>window.location.href</code></li></ol><p><strong>解决方案：</strong></p><ol><li>主应用提供一个路径比如说 <code>https://host/empty</code> ，这个路径返回不包含任何内容也不会跳转，子应用设置 <a href="/doc/api/startApp.html#attrs">attr</a> 为 <code>{src:&#39;https://host/empty&#39;}</code>，这样 <code>iframe</code> 的 <code>src</code> 就是 <code>https://host/empty</code></li><li><code>vite</code> 子应用所有的 <code>location</code> 操作都必须采用 <code>window.$wujie.location</code></li><li><code>jsIgnores</code> 对应的 <code>js</code> 文件所有的 <code>location</code> 操作都必须采用 <code>window.$wujie.location</code></li></ol><h2 id="_11、子应用的相对地址图片没有替换成绝对地址" tabindex="-1">11、子应用的相对地址图片没有替换成绝对地址 <a class="header-anchor" href="#_11、子应用的相对地址图片没有替换成绝对地址" aria-label="Permalink to &quot;11、子应用的相对地址图片没有替换成绝对地址&quot;">​</a></h2><p><strong>原因：</strong> 子应用通过 <code>v-html</code>、<code>innerHtml</code>或者在<code>template</code>中动态添加<code>style</code>时，框架默认的<code>plugin</code>无法处理这种场景</p><p><strong>解决办法：</strong> 在子应用入口<code>main</code>文件最上面 <code>import &quot;./config&quot;</code>，<code>config</code>具体代码：</p><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> (window</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">__POWERED_BY_WUJIE__) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// eslint-disable-next-line</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">window</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">__webpack_public_path__</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">window</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">__WUJIE_PUBLIC_PATH__</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div>`,43),c=[n];function r(l,p,d,i,h,g){return o(),a("div",null,c)}const w=e(t,[["render",r]]);export{m as __pageData,w as default};
